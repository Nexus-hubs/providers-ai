<!DOCTYPE html>
<html lang="en">
 <head>
   <meta charset="UTF-8" />
   <meta name="viewport" content="width=device-width, initial-scale=1.0" />
   <title>TRON Recognizer - Interactive 3D</title>
   <style>
     :root {
       color-scheme: dark;
       font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
     }

     body {
       margin: 0;
       background: radial-gradient(circle at top, #0f1b2b 0%, #040404 55%, #000 100%);
       overflow: hidden;
     }

     canvas {
       display: block;
     }

     .hud {
       position: fixed;
       inset: 1.5rem auto auto 1.5rem;
       padding: 1rem 1.25rem;
       background: color-mix(in srgb, #0f1724 70%, transparent);
       border: 1px solid rgba(255, 40, 40, 0.35);
       box-shadow: 0 0 20px rgba(255, 32, 32, 0.15);
       border-radius: 10px;
       max-width: 320px;
       line-height: 1.4;
       color: #f4f6ff;
       backdrop-filter: blur(8px);
     }

     .hud h1 {
       margin: 0 0 0.5rem;
       font-size: 1.15rem;
       letter-spacing: 0.08em;
       text-transform: uppercase;
       color: #ff3a3a;
     }

     .hud p {
       margin: 0.35rem 0;
       font-size: 0.88rem;
       color: rgba(220, 228, 255, 0.9);
     }

     .hud kbd {
       display: inline-flex;
       align-items: center;
       justify-content: center;
       min-width: 1.8em;
       padding: 0 0.35em;
       margin: 0 0.15em;
       border-radius: 6px;
       border: 1px solid rgba(255, 58, 58, 0.55);
       background: rgba(5, 10, 16, 0.7);
       color: #ff9696;
       font-size: 0.75rem;
       box-shadow: inset 0 0 8px rgba(255, 32, 32, 0.3);
     }

     @media (max-width: 600px) {
       .hud {
         inset: auto 1rem 1rem 1rem;
         max-width: none;
       }
     }
   </style>
 </head>
 <body>
   <div class="hud">
     <h1>Recognizer // TRON Grid</h1>
     <p>Drag to orbit. Scroll to zoom. Right-click to pan.</p>
     <p><kbd>Space</kbd> deploys the capture module. <kbd>S</kbd> toggles the scanner sweep.</p>
   </div>
   <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.min.js"></script>
   <script type="importmap">
     {
       "imports": {
         "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
         "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
       }
     }
   </script>
   <script type="module">
     import * as THREE from "three";
     import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
     import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
     import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
     import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";

     const scene = new THREE.Scene();
     scene.fog = new THREE.FogExp2(0x020309, 0.05);

     const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
     camera.position.set(7, 6, 12);

     const renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
     renderer.outputColorSpace = THREE.SRGBColorSpace;
     renderer.toneMapping = THREE.ACESFilmicToneMapping;
     renderer.shadowMap.enabled = true;
     document.body.appendChild(renderer.domElement);

     const composer = new EffectComposer(renderer);
     const renderPass = new RenderPass(scene, camera);
     composer.addPass(renderPass);
     const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.85, 0.6, 0.01);
     bloomPass.threshold = 0.0;
     bloomPass.strength = 1.5;
     bloomPass.radius = 0.45;
     composer.addPass(bloomPass);

     const controls = new OrbitControls(camera, renderer.domElement);
     controls.target.set(0, 1.5, 0);
     controls.enableDamping = true;
     controls.maxDistance = 25;
     controls.minDistance = 4;
     controls.maxPolarAngle = Math.PI * 0.62;

     const hemiLight = new THREE.HemisphereLight(0x52b6ff, 0x030306, 0.6);
     scene.add(hemiLight);

     const keyLight = new THREE.DirectionalLight(0xff2a2a, 0.75);
     keyLight.position.set(8, 10, 6);
     keyLight.castShadow = true;
     keyLight.shadow.mapSize.set(2048, 2048);
     scene.add(keyLight);

     const rimLight = new THREE.DirectionalLight(0x1cd6ff, 0.5);
     rimLight.position.set(-6, 12, -10);
     scene.add(rimLight);

     const floorMaterial = new THREE.MeshStandardMaterial({
       color: 0x02111f,
       emissive: 0x041c33,
       emissiveIntensity: 0.35,
       metalness: 0.6,
       roughness: 0.4,
       transparent: true,
       opacity: 0.9,
     });

     const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), floorMaterial);
     floor.rotation.x = -Math.PI / 2;
     floor.receiveShadow = true;
     scene.add(floor);

     const grid = new THREE.GridHelper(160, 80, 0x0ff1ff, 0x0ff1ff);
     grid.material.opacity = 0.15;
     grid.material.transparent = true;
     grid.position.y = 0.01;
     scene.add(grid);

     const recognizer = new THREE.Group();
     recognizer.position.y = 3.2;
     scene.add(recognizer);

     const darkMaterial = new THREE.MeshStandardMaterial({
       color: 0x08090b,
       metalness: 0.65,
       roughness: 0.45,
       emissive: 0x000000,
     });

     const neonMaterial = new THREE.LineBasicMaterial({
       color: 0xff3030,
       linewidth: 2,
     });

     function addPanelWithEdges(geometry, material, edgeMaterial) {
       const mesh = new THREE.Mesh(geometry, material);
       mesh.castShadow = true;
       mesh.receiveShadow = true;
       const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geometry), edgeMaterial);
       mesh.add(edges);
       return mesh;
     }

     // Dimensions approximating a 3:2:4 (width:depth:height) proportion
     const scale = 0.9;
     const legHeight = 6.5 * scale;
     const legWidth = 1.8 * scale;
     const legDepth = 2.2 * scale;
     const legOffsetX = 4.5 * scale;

     function createLeg(sign = 1) {
       const legGroup = new THREE.Group();

       const leg = addPanelWithEdges(new THREE.BoxGeometry(legWidth, legHeight, legDepth), darkMaterial, neonMaterial);
       leg.position.y = 0;
       legGroup.add(leg);

       const foot = addPanelWithEdges(new THREE.BoxGeometry(legWidth * 1.4, 0.8 * scale, legDepth * 1.3), darkMaterial, neonMaterial);
       foot.position.set(0, -legHeight / 2 - 0.4 * scale, 0);
       legGroup.add(foot);

       const innerChop = addPanelWithEdges(new THREE.BoxGeometry(legWidth * 0.6, legHeight * 0.55, legDepth * 0.6), darkMaterial, neonMaterial);
       innerChop.position.set(-sign * legWidth * 0.25, -0.3 * scale, 0);
       legGroup.add(innerChop);

       legGroup.position.x = sign * legOffsetX;
       return legGroup;
     }

     const leftLeg = createLeg(-1);
     const rightLeg = createLeg(1);
     recognizer.add(leftLeg, rightLeg);

     const beam = addPanelWithEdges(new THREE.BoxGeometry(legOffsetX * 2 + legWidth * 1.1, 2.2 * scale, 2.8 * scale), darkMaterial, neonMaterial);
     beam.position.y = legHeight / 2 + 1.2 * scale;
     recognizer.add(beam);

     const beamDetail1 = addPanelWithEdges(new THREE.BoxGeometry(legOffsetX * 1.6, 0.5 * scale, 1.2 * scale), darkMaterial, neonMaterial);
     beamDetail1.position.set(0, beam.position.y + 0.9 * scale, 0);
     recognizer.add(beamDetail1);

     const cargoJaw = addPanelWithEdges(new THREE.BoxGeometry(legOffsetX * 1.2, 1.3 * scale, 2.2 * scale), darkMaterial, neonMaterial);
     cargoJaw.position.set(0, beam.position.y - 1.8 * scale, 0);
     recognizer.add(cargoJaw);

     const jawClawLeft = addPanelWithEdges(new THREE.BoxGeometry(legWidth * 0.5, 1.6 * scale, legDepth * 0.7), darkMaterial, neonMaterial);
     jawClawLeft.position.set(-legOffsetX * 0.35, cargoJaw.position.y - 0.9 * scale, 0);
     recognizer.add(jawClawLeft);

     const jawClawRight = jawClawLeft.clone();
     jawClawRight.position.x *= -1;
     recognizer.add(jawClawRight);

     const headGeometry = new THREE.CylinderGeometry(legOffsetX * 0.7, legOffsetX * 1.05, 1.6 * scale, 4, 1);
     const head = addPanelWithEdges(headGeometry, darkMaterial, neonMaterial);
     head.rotation.y = Math.PI / 4;
     head.position.y = beam.position.y + 1.9 * scale;
     recognizer.add(head);

     const headCap = addPanelWithEdges(new THREE.CylinderGeometry(legOffsetX * 0.45, legOffsetX * 0.85, 0.9 * scale, 4, 1), darkMaterial, neonMaterial);
     headCap.rotation.y = Math.PI / 4;
     headCap.position.y = head.position.y + 1.05 * scale;
     recognizer.add(headCap);

     const antenna = addPanelWithEdges(new THREE.BoxGeometry(0.3 * scale, 1.3 * scale, 0.3 * scale), darkMaterial, neonMaterial);
     antenna.position.set(0, headCap.position.y + 1.3 * scale, 0);
     recognizer.add(antenna);

     const emissiveStrips = [];
     function addNeonStrip(points) {
       const geometry = new THREE.BufferGeometry().setFromPoints(points);
       const strip = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff4a4a, linewidth: 2 }));
       recognizer.add(strip);
       emissiveStrips.push(strip);
     }

     const stripHeight = beam.position.y + 0.4 * scale;
     addNeonStrip([
       new THREE.Vector3(-legOffsetX, stripHeight, 1.4 * scale),
       new THREE.Vector3(legOffsetX, stripHeight, 1.4 * scale),
     ]);
     addNeonStrip([
       new THREE.Vector3(-legOffsetX, stripHeight, -1.4 * scale),
       new THREE.Vector3(legOffsetX, stripHeight, -1.4 * scale),
     ]);

     const scanMaterial = new THREE.MeshBasicMaterial({
       color: 0xff3f3f,
       transparent: true,
       opacity: 0.28,
       blending: THREE.AdditiveBlending,
       depthWrite: false,
     });
     const scanner = new THREE.Mesh(new THREE.PlaneGeometry(legOffsetX * 2.2, legHeight * 1.4), scanMaterial);
     scanner.rotation.y = Math.PI / 2;
     scanner.position.set(0, beam.position.y, 0);
     scene.add(scanner);

     const clock = new THREE.Clock();

     const jawState = {
       target: 0,
       current: 0,
     };

     let scanEnabled = true;

     window.addEventListener("keydown", (event) => {
       if (event.code === "Space") {
         jawState.target = jawState.target === 0 ? 1 : 0;
       }
       if (event.code === "KeyS") {
         scanEnabled = !scanEnabled;
         scanner.visible = scanEnabled;
       }
     });

     function resize() {
       const { innerWidth: width, innerHeight: height } = window;
       camera.aspect = width / height;
       camera.updateProjectionMatrix();
       renderer.setSize(width, height);
       composer.setSize(width, height);
     }
     window.addEventListener("resize", resize);

     function animate() {
       requestAnimationFrame(animate);
       const elapsed = clock.getElapsedTime();

       const hover = Math.sin(elapsed * 1.4) * 0.25;
       recognizer.position.y = 3.2 + hover;

       jawState.current = THREE.MathUtils.lerp(jawState.current, jawState.target, 0.07);
       const jawOffset = THREE.MathUtils.mapLinear(jawState.current, 0, 1, 0, -1.4 * scale);
       cargoJaw.position.y = beam.position.y - 1.8 * scale + jawOffset;
       jawClawLeft.position.y = cargoJaw.position.y - 0.9 * scale;
       jawClawRight.position.y = jawClawLeft.position.y;

       if (scanEnabled) {
         const scanT = (Math.sin(elapsed * 0.85) + 1) / 2;
         scanner.position.y = beam.position.y + THREE.MathUtils.lerp(legHeight * 0.65, -legHeight * 0.85, scanT);
         scanner.material.opacity = 0.18 + 0.18 * Math.sin(elapsed * 1.7 + Math.PI / 3);
       }

       emissiveStrips.forEach((strip, index) => {
         const intensity = 0.6 + 0.4 * Math.sin(elapsed * 2 + index);
         strip.material.opacity = intensity;
         strip.material.transparent = true;
         strip.material.needsUpdate = true;
       });

       controls.update();
       composer.render();
     }

     resize();
     animate();
   </script>
 </body>
</html>
 
EOF
)